name: Auto-merge audit bot PRs

on:
  pull_request:
    types: [opened, reopened, synchronize, labeled, ready_for_review]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  enable-automerge:
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.user.login == 'github-actions[bot]' &&
      contains(github.event.pull_request.labels.*.name, 'audit:auto') &&
      github.event.pull_request.draft == false

    steps:
      - name: Ensure required checks are successful
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const ref = pr.head.sha;

            const checks = await github.rest.checks.listForRef({ owner, repo, ref, per_page: 100 });
            const required = new Set([
              "lint-and-test",
              "check-guardrails",
              "enforce-pr-body",
              "evidence-links-present",
              "iso-mapping-confirmed",
            ]);

            const latestByName = new Map();
            for (const c of checks.data.check_runs) {
              latestByName.set(c.name, c);
            }

            const missing = [];
            const failing = [];
            for (const name of required) {
              const run = latestByName.get(name);
              if (!run) {
                missing.push(name);
              } else if (run.status !== "completed" || run.conclusion !== "success") {
                failing.push(`${name}:${run.conclusion || run.status}`);
              }
            }

            if (missing.length || failing.length) {
              core.setFailed(
                `Not ready for auto-merge. Missing: ${missing.join(", ") || "none"}; Failing: ${failing.join(", ") || "none"}`
              );
            }

      - name: Wait for stable mergeable state
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const attempts = 5;
            const delayMs = 5000;

            let state = "unknown";
            for (let i = 0; i < attempts; i++) {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              state = data.mergeable_state;
              if (state && state !== "unknown" && state !== "unstable") {
                core.info(`mergeable_state=${state} (attempt ${i + 1})`);
                return;
              }
              core.info(`mergeable_state=${state || "(null)"}; retrying in ${delayMs}ms`);
              await new Promise(res => setTimeout(res, delayMs));
            }

            if (state === "unstable" || state === "unknown" || !state) {
              core.notice(`Skipping auto-merge enable: mergeable_state=${state}. Will rely on next workflow run.`);
              return;
            }

      - name: Enable auto-merge (squash)
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            const query = `
              mutation EnableAutoMerge($pullRequestId: ID!) {
                enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {
                  pullRequest { number autoMergeRequest { enabledAt } }
                }
              }`;

            await github.graphql(query, { pullRequestId: pr.node_id });
            core.info(`Auto-merge enabled for PR #${pr.number}`);
